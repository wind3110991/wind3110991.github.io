本人使用Java快一年时间了，从最早大学时候对Java的憎恶，到逐渐接受，到工作中体会到了Java开发的各种便捷与福利，这确实是一门不错的开发语言。不仅是Intellij开发Java程序的爽快，还有无需手动管理内存的便捷、Maven管理依赖的整洁、SpringCloud(SpringBoot)大礼包的规整等等。  

所以，作为一个有追求的Java程序员——深入Java底层，了解和掌握GC的机制，应该算是必备的技能了。本文即我在学习过程中的一些个人观点以及心得，不正之处敬请指正。

![Thumper](http://ww1.sinaimg.cn/large/afce444dgy1g1an306m9zj20nw0eg3z5.jpg)

### 一、 JVM的运行数据区 
首先我简单来画一张JVM的结构原理图： 
![Thumper](http://ww1.sinaimg.cn/large/afce444dgy1g1an2tdm1jj20v50j5wfb.jpg)

我们重点关注JVM在运行时的数据区，你可以看到在程序运行时，大致有5个部分：

#### （1）方法区 
不止是存“方法”，而是存储整个class文件的信息，JVM运行时，类加载器子系统将会提取`class文件里面的类信息`，并将其存放在方法区中。例如类的名称、类的类型（枚举、类、接口）、字段、方法等等。

#### （2）堆（Heap） 
熟悉c/c++编程的同学们应该相当熟悉Heap了，而对于Java而言，每个应用都唯一对应一个JVM实例，而每一个JVM实例唯一对应一个堆。`堆主要包括关键字new的对象实例、this指针，或者数组都放在堆中，并由应用所有的线程共享`。堆由JVM的自动内存管理机制所管理，名为垃圾回收——GC（garbage collection）。


#### （3）栈（Stack） 
`操作系统内核为某个进程或者线程建立的存储区域`,它保存着一个线程中的方法的调用状态，它具有先进后出的特性。在栈中的数据大小与生命周期严格来说都是确定的，例如在一个函数中声明的int变量便是存储在stack中，它的大小是固定的，在函数退出后它的生命周期也从此结束。在栈中，每一个方法对应一个栈帧，JVM会对Java栈执行两种操作： `压栈和出栈`。 这两种操作在执行时都是以栈帧为单位的。还有一些常量、静态变量、即时编译器编译后的代码等数据。


#### （4）PC寄存器
pc寄存器用于存放一条指令的地址，每一个线程都有一个PC寄存器。

#### （5）本地方法栈
用来调用其他语言的本地方法，例如C/C++写的本地代码， 这些方法在本地方法栈中执行，而不会在Java栈中执行。